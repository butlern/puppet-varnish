# ************************************************************
# THIS IS AUTO-GENERATED BY PUPPET
# LOCAL MODIFICATION WILL BE OVERWRITTEN BY PUPPET
# ************************************************************
#
# Main vcl configuration. This sets up the following:
# - Backend Health Check Probe
# - Backend Servers
# - Default Director
# - Purge Acls
# - Imports
# - Basic vcl subroutines
# - Includes extra vcl file if defined

# ************************************************************
# Probe
# ************************************************************
probe backend_health_check {
    .url = "<%= @health_check_url %>";
    .timeout = <%= @health_check_timeout %>;
    .interval = <%= @health_check_interval %>;
    .window = <%= @health_check_window %>;
    .threshold = <%= @health_check_threshold %>;
    .expected_response = <%= @health_check_expected_response %>;
}

# ************************************************************
# Backends
# ************************************************************
<%
  hosts = @backends
  backends = hosts.map do |host|
    if host =~ /:/
      host.split(':')
    else
      [ host, '80' ]
    end
  end
  backends.each_with_index do |v,i|
-%>
backend backend<%= i %> {
    .host = "<%= v[0] %>";
    .port = "<%= v[1] %>";
    .first_byte_timeout = <%= @first_byte_timeout %>;
    .probe = backend_health_check;
}
<% end -%>

# ************************************************************
# Saint Mode Backend
# https://www.varnish-software.com/static/book/Saving_a_request.html#example-evil-backend-hack
# ************************************************************
backend fail {
    .host = "127.0.0.1";
    .port = "12871";
    .probe = {
        .url = "/fail";
        .initial = 0;
        .interval = 1d;
    }
}

# ************************************************************
# Director
# ************************************************************
director default round-robin {
<% backends.each_index do |i| -%>
    { .backend = backend<%= i %>; }
<% end -%>
}

# ************************************************************
# Purge Acls, host/networks allowed to purge content.
# ************************************************************
acl purge {
<% @purge_acls.each do |acl| -%>
    <%= acl %>;
<% end -%>
}

# ************************************************************
# Vmod Imports
# ************************************************************
import std;
<%
  @vmods.map! do |vmod|
    vmod.gsub(/libvmod-(.+)/, '\1')
  end
-%>
<% @vmods.each do |vmod| -%>
import <%= vmod %>;
<% end -%>

# ************************************************************
# Core Config
# ************************************************************
sub vcl_recv {
    # Restart Logic on failed backends
    # https://www.varnish-software.com/static/book/Saving_a_request.html#example-evil-backend-hack
    if (req.restarts == 0) {
        set req.backend = default;
    } else {
       set req.backend = fail;
    }

    # Set Grace. This is the amount of time that we will serve stale content.
    if (req.backend.healthy) {
       set req.grace = 30s;
       std.log ("[Receive] " + req.url + "(Back-end " + req.backend + " healthy, Grace: " + req.grace + ")");
    } else {
       set req.grace = 24h;
       std.log ("[Receive] " + req.url + "(Back-end " + req.backend + " unhealthy, Grace: " + req.grace + ")");
    }

    # Normalize Accept-Encoding to avoid duplicate cache
    # https://www.varnish-cache.org/trac/wiki/VCLExampleNormalizeAcceptEncoding
    if (req.http.Accept-Encoding) {
        if (req.url ~ "\.(jpg|png|gif|gz|tgz|bz2|tbz|mp3|ogg)$") {
            # No point in compressing these
            remove req.http.Accept-Encoding;
        } elsif (req.http.Accept-Encoding ~ "gzip") {
            set req.http.Accept-Encoding = "gzip";
        } elsif (req.http.Accept-Encoding ~ "deflate") {
            set req.http.Accept-Encoding = "deflate";
        } else {
            # unkown algorithm
            remove req.http.Accept-Encoding;
        }
    }

    # Allow Purging from purge acl clients
    if (req.request == "PURGE") {
        if (!client.ip ~ purge) {
            error 405 "Not allowed.";
        }
        return(lookup);
    }

}

sub vcl_pipe {
    set bereq.http.connection = "close";
}

sub vcl_hit {
    if (req.request == "PURGE") {
        purge;
        error 200 "Purged.";
    }
}

sub vcl_miss {
    if (req.request == "PURGE") {
        purge;
        error 200 "Purged.";
    }
}

sub vcl_fetch {
    if (beresp.status >= 500) {
        set beresp.saintmode = 20s;
        std.log ("[Fetch ] " + bereq.url + " (Saint: 20s)");
        return(restart);
    }

    # Set Grace. Determines how long objects are kept in cache after they expire
    set beresp.grace = 24h;

    set beresp.http.X-Cacheable = "YES";

    std.log ("[Fetch ] " + bereq.url + " (Grace: " + beresp.grace + ", TTL: " + beresp.ttl + ", Status: " + beresp.status + ", Cacheable: YES)");
}

sub vcl_deliver {
    # Add cache hits
    if (obj.hits > 0) {
        set resp.http.X-Cache = "HIT";
        set resp.http.X-Cache-Hits = obj.hits;
    } else {
        set resp.http.X-Cache = "MISS";
    }

    set resp.http.X-BackEnd = req.backend;
    set resp.http.X-Restarts = req.restarts;
}

sub vcl_error {
    std.log ("[Error ] " + req.url + " (Status: " + obj.status + ", Restarts: " + req.restarts + ")");
    if (req.restarts == 0) {
        return(restart);
    }
}

<% if @extra_conf  -%>
# ************************************************************
# Extra Config
# ************************************************************
include "<%= @extra_vcl.split('/').last %>";
<% end -%>
