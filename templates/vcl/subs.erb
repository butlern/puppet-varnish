# ************************************************************
# THIS IS AUTO-GENERATED BY PUPPET
# LOCAL MODIFICATION WILL BE OVERWRITTEN BY PUPPET
# ************************************************************
#
sub vcl_recv {
    # Restart Logic on failed backends
    # https://www.varnish-software.com/static/book/Saving_a_request.html#example-evil-backend-hack
    if (req.restarts == 0) {
        set req.backend = default;
    } else {
       set req.backend = fail;
    }

    # Set Grace. This is the amount of time that we will serve stale content.
    if (req.backend.healthy) {
       set req.grace = 30s;
       std.log ("[Receive] " + req.url + "(Back-end " + req.backend + " healthy, Grace: " + req.grace + ")");
    } else {
       set req.grace = 24h;
       std.log ("[Receive] " + req.url + "(Back-end " + req.backend + " unhealthy, Grace: " + req.grace + ")");
    }

    # Normalize Accept-Encoding to avoid duplicate cache
    # https://www.varnish-cache.org/trac/wiki/VCLExampleNormalizeAcceptEncoding
    if (req.http.Accept-Encoding) {
        if (req.url ~ "\.(jpg|png|gif|gz|tgz|bz2|tbz|mp3|ogg)$") {
            # No point in compressing these
            remove req.http.Accept-Encoding;
        } elsif (req.http.Accept-Encoding ~ "gzip") {
            set req.http.Accept-Encoding = "gzip";
        } elsif (req.http.Accept-Encoding ~ "deflate") {
            set req.http.Accept-Encoding = "deflate";
        } else {
            # unkown algorithm
            remove req.http.Accept-Encoding;
        }
    }

    # Allow Purging from purge acl clients
    if (req.request == "PURGE") {
        if (!client.ip ~ purge) {
            error 405 "Not allowed.";
        }
        return(lookup);
    }

}

sub vcl_pipe {
    set bereq.http.connection = "close";
}

sub vcl_hit {
    if (req.request == "PURGE") {
        purge;
        error 200 "Purged.";
    }
}

sub vcl_miss {
    if (req.request == "PURGE") {
        purge;
        error 200 "Purged.";
    }
}

sub vcl_fetch {
    if (beresp.status >= 500) {
        set beresp.saintmode = 20s;
        std.log ("[Fetch ] " + bereq.url + " (Saint: 20s)");
        return(restart);
    }

    # Set Grace. Determines how long objects are kept in cache after they expire
    set beresp.grace = 24h;

    set beresp.http.X-Cacheable = "YES";

    std.log ("[Fetch ] " + bereq.url + " (Grace: " + beresp.grace + ", TTL: " + beresp.ttl + ", Status: " + beresp.status + ", Cacheable: YES)");
}

sub vcl_deliver {
    # Add cache hits
    if (obj.hits > 0) {
        set resp.http.X-Cache = "HIT";
        set resp.http.X-Cache-Hits = obj.hits;
    } else {
        set resp.http.X-Cache = "MISS";
    }

    set resp.http.X-BackEnd = req.backend;
    set resp.http.X-Restarts = req.restarts;
}

sub vcl_error {
    std.log ("[Error ] " + req.url + " (Status: " + obj.status + ", Restarts: " + req.restarts + ")");
    if (req.restarts == 0) {
        return(restart);
    }
}
